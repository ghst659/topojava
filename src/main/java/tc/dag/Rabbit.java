package tc.dag;

import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class Rabbit<T, V> {
    private Graph<T> dag = null;
    private NodeOperator<T, V> actor = null;
    private Set<T> runSpecNodes = new HashSet<>();
    private EnumMap<Graph.Parts, Set<T>> runSpecSubgraph = null;
    private ExecutorService runVarPool = null;
    private Map<T, Future<V>> runVarEntries = new HashMap<>();
    private Map<T, Long> runVarExits = new HashMap<>();
    private Event runVarStop = new Event();
    private Set<T> runVarBlocked =new HashSet<>();

    /**
     * Constructs the Rabbit from GRAPH and NODEOPERATOR
     *
     * @param graph        the graph to traverse
     * @param nodeOperator the operator on nodes.
     */
    public Rabbit(Graph<T> graph, NodeOperator<T, V> nodeOperator) {
        this.dag = graph;
        this.actor = nodeOperator;
    }

    /**
     * Starts the graph traversal with max CONCURRENCY and TIMEOUT wait time, from INITIAL to TERMINAL nodes.
     *
     * @param concurrency maximum concurrency to use during traversal.
     * @param timeout     max time in milliseconds to complete the traversal.
     * @param initial     collection of initial nodes for the traversal
     * @param terminal    collection of termianl ndoes for the traversal.
     */
    public void run(int concurrency, long timeout, Collection<T> initial, Collection<T> terminal) {
        EnumMap<Graph.Parts, Set<T>> subSpec = this.dag.getSubgraph(initial, terminal);
        if (concurrency > 0 && !subSpec.get(Graph.Parts.INITIALS).isEmpty()) {
            synchronized (this) {
                this.runVarStop.clear();
                this.runVarBlocked.clear();
                this.runVarEntries.clear();
                this.runVarExits.clear();
                this.runSpecSubgraph = subSpec;
                this.runVarPool = Executors.newFixedThreadPool(concurrency);
            }
            this.visitNodes(subSpec.get(Graph.Parts.INITIALS));
            this.awaitCompletion(Math.abs(timeout));
        }
    }

    /**
     * Visit NODES.  This is a non-blocking call.
     *
     * @param nodesToVisit the collection of nodes to visit.
     */
    protected synchronized void visitNodes(Collection<T> nodesToVisit) {
        if (nodesToVisit != null && !nodesToVisit.isEmpty()) {
            for (T node : nodesToVisit) {
                if (!this.runVarStop.isSet() && this.runSpecSubgraph.get(Graph.Parts.NODES).contains(node) &&
                    !this.runVarEntries.containsKey(node)) {
                    Set<T> prerequisites = this.dag.getPredecessors(node);
                    prerequisites.retainAll(this.runSpecSubgraph.get(Graph.Parts.NODES));
                    if (this.getCompletions().keySet().containsAll(prerequisites)) {
                        Future<V> future = this.runVarPool.submit(() -> this.visitOneNode(node));
                        this.runVarEntries.put(node, future);
                    }
                }
            }
        }
    }

    /**
     * Per-thread method to visit NODE, calling the NodeOperator.
     *
     * @param node node to be visited.
     * @return the V value generated by NodeOperator when operating on the node.
     * @throws Exception any exception thrown by the NodeOperator.
     */
    protected V visitOneNode(T node) throws Exception {
        V result = null;
        try {
            result = this.actor.operate(node);
        } catch (NonTerminatingException e) {
            this.updateBlock(node);
            throw e;
        } catch (Exception e) {
            this.updateBlock(node);
            this.runVarStop.set();
            throw e;
        } finally {
            this.runVarExits.put(node, System.currentTimeMillis());
        }
        synchronized (this) {
            Set<T> concluded = new HashSet<>(this.getCompletions().keySet());
            concluded.addAll(this.runVarBlocked);
            Set<T> requiredCoverage = this.runSpecSubgraph.get(Graph.Parts.NODES);
            if (concluded.containsAll(requiredCoverage)) {
                this.runVarStop.set();
                this.runVarPool.shutdown();
            } else {
                this.visitNodes(this.dag.getSuccessors(node));
            }
        }
        return result;
    }

    /**
     * Update the blocked-node set during this run with all downstream nodes
     * from NODE.
     * @param node the blocking upstream node.
     */
    protected void updateBlock(T node) {
        Set<T> blockedByNode = new HashSet<T>(this.dag.getDownstreamNodes(node));
        blockedByNode.retainAll(this.runSpecSubgraph.get(Graph.Parts.NODES));
        synchronized(this) {
            this.runVarBlocked.addAll(blockedByNode);
        }
    }

    /**
     * Wait for the completion of the graph traversal.
     *
     * @param timeout maximum waiting time, in milliseconds.
     */
    protected void awaitCompletion(long timeout) {
        try {
            this.runVarStop.await(timeout);
            this.runVarPool.awaitTermination(timeout, TimeUnit.MILLISECONDS);
            synchronized (this) {
                for (boolean allDone = false; !allDone; ) {
                    allDone = true;
                    for (Future<V> nodeResult : this.runVarEntries.values()) {
                        if (!nodeResult.isDone()) {
                            allDone = false;
                            break;
                        }
                    }
                }
            }
        } catch (InterruptedException e) {
            this.runVarStop.set();
        }
    }
    /**
     * Get the results of visiting NODE.
     *
     * @param node the node whose visit result is to be obtained.
     * @return a V value generated by the NodeOperator.
     * @throws Exception any exception thrown by the NodeOperator.
     */
    public synchronized V getResult(T node) throws Exception {
        V result = null;
        if (node != null && this.runVarEntries.containsKey(node) && this.runVarEntries.get(node).isDone()) {
            result = this.runVarEntries.get(node).get();
        }
        return result;
    }
    /**
     * Get a set of all nodes blocked by upstream exceptions.
     * @return a set of nodes.
     */
    public synchronized Set<T> getBlocked() {
        Set<T> result = new HashSet<>(this.runVarBlocked);
        return result;
    }
    /**
     * Get a table of all completed nodes and their exit times.
     *
     * @return a Map of nodes to completion times.
     */
    public synchronized Map<T, Long> getCompletions() {
        Map<T, Long> result = new HashMap<>();
        result.putAll(this.runVarExits);
        return result;
    }

    /**
     * Local class to provide similar functionality to the Python concurrent.futures.Event
     */
    private static class Event {
        private boolean state = false;
        /**
         * Checks if this event has been set.
         *
         * @return boolean state of this event.
         */
        public synchronized boolean isSet() {
            return this.state;
        }
        /**
         * Set this event's state to true.
         */
        public synchronized void set() {
            this.state = true;
            this.notifyAll();
        }
        /**
         * Clears this event's state, ie. to false.
         */
        public synchronized void clear() {
            this.state = false;
        }
        /**
         * Waits until this event's state is true.
         *
         * @param timeout maximum time to wait, in milliseconds
         * @throws InterruptedException if the wait is interrupted.
         */
        public synchronized void await(long timeout) throws InterruptedException {
            if (!this.state) {
                this.wait(timeout);
            }
        }
    }
}
